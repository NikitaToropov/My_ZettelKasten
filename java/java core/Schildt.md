# Классы и методы

## Перегрузка методов

`@Overload`

- одного имя для разных методов
- должны отличаться набор параметров

---

## Рекурсия

- плодит стеки при каждом вложенном вызове
- черевато StackOverflowError

---

## Управление доступом

### `Private`(только для членов и вложенных классов)

- член/класс доступен только другим членам этого же класса

### `Public`

- член/класс доступен везде

### `Protected`(только для членов и вложенных классов)

- член доступен всем наследникам

### `Default` (`PackageLocal`)

- член/класс доступен только в пакете

---

## `Static`

- Член доступен из класса (глобальные)
- Переменные класса
    - Все экземпляры ссылаются на один и тот же член
- Методы
    - Могут обращаться только к статическим членам
- Никак не могут ссылаться на `this` и `super`
- Если инициализация требует вычислений, используется статический блок

```
class UseStatic {
    static int а =3; static int Ь;
    
    static {
        System.out.println("Статический блок инициализирован.");
        Ь = а * 4;
    }
}    
```

---

## `Final`

- предотвращает изменение содержимого
- инициализируется
    - inline
    - в статическом блоке
    - в конструкторе
- могут быть
    - поля
    - методы
    - локальные переменные

---

## Вложенные классы

- один класс определен в другом
- область действия вложенного ограничена областью внешнего класса
    - `B` вложен `A`. `B` может существовать только как `A.B`
- вложенные класс имеет доступ к членам класса в который он вложен
    - в тч и `private`
- появились в `Java 1.1`

### Статический вложенный класс `static`

- может обращаться только к статическим членам внешнего класса

### Нестатический вложенный класс (Внутренний)

- доступны все члены внешнего

```
class Outer {
  int outer х = 100;
  
  void test() {
    // Inner может быть создан только в контексте классаOutеr
    Inner inner = new Inner(); 
    inner.display();
  }

  class Inner {
    void display () {
      System.out.println("вывoд: outer_x " + outer_x);
    }
  }
}

class InnerClassDemo {
  public static void main (String args []) {
    Outer outer = new Outer();
    uter.test();
  }
}

// вывод: outer_x = 100
```

---

## `String`

- любая символьная строка - String
- final
- определены методы
    - equals() - сравнивает строки посимвольно
    - charAt() - символ по индексу
    - length() - длина символьной строки

---

## Аргументы переменной длины `varargs` (done)

- `тип имя_метода(тип ... имя_параметра)`
    - реализация - массив `тип[]`
    - можно вызывать без параметров вообще
        - `имя_параметра.length() == null`
- можно перегружать
- ограничения
    - параметр переменной длины указывается последним в списке параметров
        - `int doit(int а, int Ь, douЬle с, int ... vals)`
    - только один параметр переменной длины на метод
    - неоднозначность при перегрузке

```
static void vaтest (int ... v) { // ...
static void vaTest(int n, int ... v) { // ...
// компилятор не поймет вызов vaTest(1), vaTest(1, 2) и тд
```

---
---

# Наследование

`ПОДКЛАСС extends СУПЕРКЛАСС`

## Доступ к членам класса

- `private` члены супера остаются закрытыми
- последовательность вызова конструкторов в иерархии
- переменная суперкласса может содержать ссылку на подкласс
    - `Sup a = new Sub();`

## `super` (done)

Нужен для ссылки из подкласса на суперкласс

- на члены суперкласса (метод или поле)
    - аналогично `this.id = id`
    - имена членов подкласса скрывают(совпадают) члены суперкласса
    - `super.членКласса()`

- на конструктор суперкласса
    - `super(список аргументов)`
    - если конструктор в подклассе переопределен и не содержит вызова `super(список аргументов)`
        - под капотом вызывается дефолтный конструктор `super()`
    - для иерархии
        - `superSuper() -> super() -> subclass()`

## Переопределение методов `@Override`

- метод подкласса переопределяет метод супера, если их сигнатуры полностью совпадают
- неопределенность если у методов совпадают имена и параметры, а возвращаемый класс нет

## Динамическая диспетчеризация методов (Runtime)

- реализация runtime полиморфизма

```
SubClass b = new SubClass()
SuperClass a = b

// a.уникальныйМетодДляКлассаB(); Ошибка компиляции
a.общийМетод(); // вызовет последнюю реализацию подкласса
```

- Набор членов определяется классом переменной
- Реализация определяется классом объекта который в переменной

## Абстрактные классы

- `модификатор доступа abstract class ИмяКласса;`
- чтобы задать суперкласс с определенной структурой, но без полной реализации
- может содержать дефолтный методы
- может содержать абстрактные методы
    - `abstract тип имя(список_параметров);`
- или вообще без методов
- нельзя сделать экземпляр
- может иметь реализацию конструктора

## `FINAL`

* Предотвращение переопределения
* Предотвращение наследования

---

# Пакеты и Интерфейсы

## Пакеты

* Инструмент управления пространством имен

### Определение пакета

* указать в начале файла `package "имя пакета"`
* для хранения - одноименная иерархия файловой системы
  * внутри лежит файл .class
  * 


