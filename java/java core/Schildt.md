# Классы и методы

## Перегрузка методов

`@Overload`

- одного имя для разных методов
- должны отличаться набор параметров

---

## Рекурсия

- плодит стеки при каждом вложенном вызове
- черевато StackOverflowError

---

## Управление доступом

### `Private`

- член доступен везде

### `Public`

- член доступен только другим членам этого же класса

### `Protected`

### `Default`

---

## `Static`

- Член доступен из класса (глобальные)
- Переменные класса
    - Все экземпляры ссылаются на один и тот же член
- Методы
    - Могут обращаться только к статическим членам
- Никак не могут ссылаться на `this` и `super`
- Если инициализация требует вычислений, используется статический блок

```
class UseStatic {
    static int а =3; static int Ь;
    
    static {
        System.out.println("Статический блок инициализирован.");
        Ь = а * 4;
    }
}    
```

---

## `Final`

- предотвращает изменение содержимого
- инициализируется
    - inline
    - в статическом боке
    - в конструкторе
- могут быть
    - поля
    - методы
    - локальные переменные

---

## Вложенные классы

- один класс определен в другом
- область действия вложенного ограничена областью внешнего класса
    - `B` вложен `A`. `B` может существовать только как `A.B`
- вложенные класс имеет доступ к членам класса в который он вложен
    - в тч и `private`
- появились в `Java 1.1`

### Статический вложенный класс `static`

- может обращаться только к статическим членам внешнего класса

### Нестатический вложенный класс (Внутренний)

- доступны все члены внешнего

```
class Outer {
  int outer х = 100;
  
  void test() {
    // Inner может быть создан только в контексте классаOutеr
    Inner inner = new Inner(); 
    inner.display();
  }

  class Inner {
    void display () {
      System.out.println("вывoд: outer_x " + outer_x);
    }
  }
}

class InnerClassDemo {
  public static void main (String args []) {
    Outer outer = new Outer();
    uter.test();
  }
}

// вывод: outer_x = 100
```

---

## `String`

- любая символьная строка - String
- final
- определены методы
    - equals() - сравнивает строки посимвольно
    - charAt() - символ по индексу
    - length() - длина символьной строки

---

## Аргументы переменной длины `varargs`

- `тип имя_метода(тип ... имя_параметра)`
  - реализация - массив `тип[]`
  - можно вызывать без параметров вообще
    - `имя_параметра.length() == null`
- можно перегружать
- ограничения
  - параметр переменной длины указывается последним в сигнатуре
    - `int doit(int а, int Ь, douЬle с, int ... vals)` 
  - только один параметр переменной длины на метод
  - неоднозначность при перегрузке
```
static void vaтest (int ... v) { // ...
static void vaTest(int n, int ... v) { // ...
// компилятор не поймет вызов vaTest(1), vaTest(1, 2) и тд
```

---
---

# Наследование

`ПОДКЛАСС extends СУПЕРКЛАСС`

## Доступ к членам класса

- `private` члены супера остаются закрытыми
- последовательность вызова конструкторов в иерархии
- переменная суперкласса может содержать ссылку на подкласс 
  - `Sup a = new Sub();`

## `super`

Нужен для ссылки из подкласса на суперкласс

  - на члены суперкласса (метод или поле)
    - имена членов подкласса скрывают(совпадают) члены суперкласса
      - аналогично `this.id = id`
    - при переопределении метода
      - `super()` в теле переопределенного метода - вызывает тот же метод у супера
        - если сигнатуры не совпадают, то это уже `Overload`
      - todo не понятно как на это влияют модификаторы 
    
  - на конструктор суперкласса
    - `super(список аргументов)`
    - если конструктор в подклассе переопределен и не содержит вызова `super(список аргументов)`
      - под капотом вызывается дефолтный конструктор `super()`
    - для иерархии
      - `superSuper() -> super() -> subclass()`

## Переопределение методов `@Override`

- метод подкласса переопределяет метод супера, если их сигнатуры полностью совпадают
- todo что если у методов совпадают имена и параметры, а возвращаемый класс нет?

## Динамическая диспетчеризация методов (Runtime)

```
//
SubClass b = new SubClass()
SuperClass a = b

// a.уникальныйМетодДляКлассаB(); Ошибка компиляции
a.уникальныйМетодДляКлассаB(); Ошибка компиляции
```


- 